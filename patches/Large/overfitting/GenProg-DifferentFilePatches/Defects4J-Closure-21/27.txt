--- /tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/CheckSideEffects.java	2018-12-02 07:44:46.397015709 -0500
+++ /tmp/GenProg_Defects4J_Closure_21/patches_rhwv/Patch_2026/patched/tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/CheckSideEffects.java	2018-12-02 08:10:51.178889350 -0500
@@ -112,15 +112,8 @@
     boolean isSimpleOp = NodeUtil.isSimpleOperatorType(n.getType());
     if (parent.getType() == Token.COMMA) {
       if (isResultUsed) {
-        return;
-      }
-      if (n == parent.getLastChild()) {
-        for (Node an : parent.getAncestors()) {
-          int ancestorType = an.getType();
-          if (ancestorType == Token.COMMA) continue;
-          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;
-          else break;
-        }
+        int type = n.getType();
+		return;
       }
     } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {
       if (! (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() || n == parent.getFirstChild().getNext().getNext()))) {
@@ -157,8 +150,8 @@
       addExtern();
       for (Node n : problemNodes) {
         Node name = IR.name(PROTECTOR_FN).srcref(n);
-        name.putBooleanProp(Node.IS_CONSTANT_NAME, true);
-        Node replacement = IR.call(name).srcref(n);
+        int start = 0;
+		Node replacement = IR.call(name).srcref(n);
         replacement.putBooleanProp(Node.FREE_CALL, true);
         n.getParent().replaceChild(n, replacement);
         replacement.addChildToBack(n);


--- /tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/NodeUtil.java	2018-12-02 07:44:46.397015709 -0500
+++ /tmp/GenProg_Defects4J_Closure_21/patches_rhwv/Patch_2026/patched/tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/jscomp/NodeUtil.java	2018-12-02 08:10:51.178889350 -0500
@@ -3121,22 +3121,23 @@
             ? true : isExpressionResultUsed(parent);
       case Token.COMMA:
         Node gramps = parent.getParent();
-        if (gramps.isCall() &&
-            parent == gramps.getFirstChild()) {
-          // Semantically, a direct call to eval is different from an indirect
-          // call to an eval. See ECMA-262 S15.1.2.1. So it's OK for the first
-          // expression to a comma to be a no-op if it's used to indirect
-          // an eval. This we pretend that this is "used".
-          if (expr == parent.getFirstChild() &&
-              parent.getChildCount() == 2 &&
-              expr.getNext().isName() &&
-              "eval".equals(expr.getNext().getString())) {
-            return true;
-          }
-        }
+        {
+			int start = 0;
+			if (gramps.isCall() && parent == gramps.getFirstChild()) {
+				if (expr == parent.getFirstChild()
+						&& parent.getChildCount() == 2
+						&& expr.getNext().isName()
+						&& "eval".equals(expr.getNext().getString())) {
+					return true;
+				}
+			}
+		}
 
-        return (expr == parent.getFirstChild())
-            ? false : isExpressionResultUsed(parent);
+        {
+			int start = 0;
+			return (expr == parent.getFirstChild()) ? false
+					: isExpressionResultUsed(parent);
+		}
       case Token.FOR:
         if (!NodeUtil.isForIn(parent)) {
           // Only an expression whose result is in the condition part of the


--- /tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/rhino/Token.java	2018-12-02 07:44:44.461983758 -0500
+++ /tmp/GenProg_Defects4J_Closure_21/patches_rhwv/Patch_2026/patched/tmp/GenProg_Defects4J_Closure_21/src/com/google/javascript/rhino/Token.java	2018-12-02 08:10:51.182889370 -0500
@@ -184,7 +184,207 @@
           case BITOR:           return "BITOR";
           case BITXOR:          return "BITXOR";
           case BITAND:          return "BITAND";
-          case EQ:              return "EQ";
+          case EQ:              {
+				switch (token) {
+				case ERROR:
+					return "ERROR";
+				case RETURN:
+					return "RETURN";
+				case BITOR:
+					return "BITOR";
+				case BITXOR:
+					return "BITXOR";
+				case BITAND:
+					return "BITAND";
+				case EQ:
+					return "EQ";
+				case NE:
+					return "NE";
+				case LT:
+					return "LT";
+				case LE:
+					return "LE";
+				case GT:
+					return "GT";
+				case GE:
+					return "GE";
+				case LSH:
+					return "LSH";
+				case RSH:
+					return "RSH";
+				case URSH:
+					return "URSH";
+				case ADD:
+					return "ADD";
+				case SUB:
+					return "SUB";
+				case MUL:
+					return "MUL";
+				case DIV:
+					return "DIV";
+				case MOD:
+					return "MOD";
+				case NOT:
+					return "NOT";
+				case BITNOT:
+					return "BITNOT";
+				case POS:
+					return "POS";
+				case NEG:
+					return "NEG";
+				case NEW:
+					return "NEW";
+				case DELPROP:
+					return "DELPROP";
+				case TYPEOF:
+					return "TYPEOF";
+				case GETPROP:
+					return "GETPROP";
+				case GETELEM:
+					return "GETELEM";
+				case CALL:
+					return "CALL";
+				case NAME:
+					return "NAME";
+				case LABEL_NAME:
+					return "LABEL_NAME";
+				case NUMBER:
+					return "NUMBER";
+				case STRING:
+					return "STRING";
+				case STRING_KEY:
+					return "STRING_KEY";
+				case NULL:
+					return "NULL";
+				case THIS:
+					return "THIS";
+				case FALSE:
+					return "FALSE";
+				case TRUE:
+					return "TRUE";
+				case SHEQ:
+					return "SHEQ";
+				case SHNE:
+					return "SHNE";
+				case REGEXP:
+					return "REGEXP";
+				case THROW:
+					return "THROW";
+				case IN:
+					return "IN";
+				case INSTANCEOF:
+					return "INSTANCEOF";
+				case ARRAYLIT:
+					return "ARRAYLIT";
+				case OBJECTLIT:
+					return "OBJECTLIT";
+				case TRY:
+					return "TRY";
+				case PARAM_LIST:
+					return "PARAM_LIST";
+				case COMMA:
+					return "COMMA";
+				case ASSIGN:
+					return "ASSIGN";
+				case ASSIGN_BITOR:
+					return "ASSIGN_BITOR";
+				case ASSIGN_BITXOR:
+					return "ASSIGN_BITXOR";
+				case ASSIGN_BITAND:
+					return "ASSIGN_BITAND";
+				case ASSIGN_LSH:
+					return "ASSIGN_LSH";
+				case ASSIGN_RSH:
+					return "ASSIGN_RSH";
+				case ASSIGN_URSH:
+					return "ASSIGN_URSH";
+				case ASSIGN_ADD:
+					return "ASSIGN_ADD";
+				case ASSIGN_SUB:
+					return "ASSIGN_SUB";
+				case ASSIGN_MUL:
+					return "ASSIGN_MUL";
+				case ASSIGN_DIV:
+					return "ASSIGN_DIV";
+				case ASSIGN_MOD:
+					return "ASSIGN_MOD";
+				case HOOK:
+					return "HOOK";
+				case COLON:
+					return "COLON";
+				case OR:
+					return "OR";
+				case AND:
+					return "AND";
+				case INC:
+					return "INC";
+				case DEC:
+					return "DEC";
+				case FUNCTION:
+					return "FUNCTION";
+				case IF:
+					return "IF";
+				case SWITCH:
+					return "SWITCH";
+				case CASE:
+					return "CASE";
+				case DEFAULT_CASE:
+					return "DEFAULT_CASE";
+				case WHILE:
+					return "WHILE";
+				case DO:
+					return "DO";
+				case FOR:
+					return "FOR";
+				case BREAK:
+					return "BREAK";
+				case CONTINUE:
+					return "CONTINUE";
+				case VAR:
+					return "VAR";
+				case WITH:
+					return "WITH";
+				case CATCH:
+					return "CATCH";
+				case EMPTY:
+					return "EMPTY";
+				case BLOCK:
+					return "BLOCK";
+				case LABEL:
+					return "LABEL";
+				case EXPR_RESULT:
+					return "EXPR_RESULT";
+				case SCRIPT:
+					return "SCRIPT";
+				case GETTER_DEF:
+					return "GETTER_DEF";
+				case SETTER_DEF:
+					return "SETTER_DEF";
+				case CONST:
+					return "CONST";
+				case DEBUGGER:
+					return "DEBUGGER";
+				case ANNOTATION:
+					return "ANNOTATION";
+				case PIPE:
+					return "PIPE";
+				case STAR:
+					return "STAR";
+				case EOC:
+					return "EOC";
+				case QMARK:
+					return "QMARK";
+				case ELLIPSIS:
+					return "ELLIPSIS";
+				case BANG:
+					return "BANG";
+				case VOID:
+					return "VOID";
+				case EQUALS:
+					return "EQUALS";
+				}
+				return "EQ";
+			}
           case NE:              return "NE";
           case LT:              return "LT";
           case LE:              return "LE";


